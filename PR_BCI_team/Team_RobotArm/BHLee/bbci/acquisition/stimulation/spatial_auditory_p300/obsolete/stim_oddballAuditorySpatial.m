function [cue_sequence, correctResponse, buttonPressed, reactionTime]= stim_oddballAuditorySpatial(N, trials, varargin);%STIM_ODDBALLAUDITORY - Stimulus Presentation for Auditory Oddball with%spatial location cues using multichannel audio output.%%Synopsis:% [cue_sequence, correctResponse, buttonPressed, reactionTime]= stim_oddballAuditory(N, trials, <OPT>)%%Arguments:% N: Number of stimuli per trial% trials: Number of trials% OPT: Struct or property/value list of optional properties:% 'speakerCount':       Scalar: number of speaker locations% 'speakerSelected':    Array specifying the selected locations% 'speakerName':        Cell array 1xSpeakerCount: names of speaker%       locations. Not yet used.% 'isi':                Scalar: inter-stimulus interval [ms]% 'isi_jitter':         Scalar: jitter in ISI [ms]% 'fs':                 Scalar: PsychPortAudio requires a set sampling rate% 'dualStim':           Boolean: if true, unique pairs of stimuli will be%       used. False, a single stimulus is presented.% 'dualDistance':       Scalar: the minimal distance between stimuli in a%       pair. For instance, with an 8 speaker setup, a dualDistance of 1%       will lead to a minimal angle between stimuli of 90 degrees.% 'countdown':          Scalar: count down from this number before a trial% 'targetCue':          String or Array: if string, it must be the complete%       path to an audio file. If an array, it must contain the audio%       stream.% 'language':           String: multi-language presentation supported% 'pahandle':           Scalar: PsychPortAudio identifier of the soundcard% 'speech':             Struct: contains filenames of speechfiles (see%       below)%%   SPEECH: Struct with different speech filenames%   'targetDirection':    String: filename%   'trialStart':         String: filename%   'trialStop':          String: filename%   'relax':              String: filename%   'nextTrial':          String: filename%   'intro':              String: filename%%Triggers:%   1: FRONT stimulus%   2: FRONT-RIGHT stimulus%   3: RIGHT stimulus%   4: BACK-RIGHT stimulus%   5: BACK stimulus%   6: BACK-LEFT stimulus%   7: LEFT stimulus%   8: FRONT-LEFT stimulus% 251: beginning of relaxing period% 252: beginning of main experiment, after countdown% 253: end of main experiment% 254: end%GLOBZ: BCI_DIR, VP_CODE, SOUND_DIRglobal BCI_DIR SOUND_DIR VP_CODE TODAY_DIRif length(varargin)>0 && isnumeric(varargin{1}),    opt= propertylist2struct('perc_dev',varargin{1}, varargin{2:end});else    opt= propertylist2struct(varargin{:});endopt= set_defaults(opt, ...    'speakerCount', 8, ...    'speakerSelected', [], ...    'soundcard', 'M-Audio FW ASIO',...    'fs', 44100, ...    'dualStim', false, ...    'dualDistance', 1, ...    'countdown', 5, ...    'language', 'english',...    'filename', 'oddball_audi', ...    'test', 0, ...    'isi', 500,...    'isi_jitter', 0, ...    'require_response', 0, ...    'response_markers', {'R 16', 'R  8'}, ...    'breakSize',5, ...    'resp_latency', 2000, ...    'req_response', false, ...    'bv_host', 'localhost');% initialize visualsopt.handle_background= stimutil_initFigure(opt);if ~isfield(opt, 'handle_cross') || isempty(opt.handle_cross),    [opt.handle_cross, opt.handle_loc]= stimutil_fixationCrossandLocations(opt);endopt.handles_all = [opt.handle_loc opt.handle_cross(1) opt.handle_cross(2)];% initialize key if response is requiredif opt.req_response    if opt.isi <= opt.resp_latency,        opt.isi = opt.resp_latency + 50;        fprintf('ISI cannot be lower than the max responsetime.\n');        fprintf('ISI is now set to: %i\n', opt.isi);    end    KbName('UnifyKeynames');        resp_button = KbName('space');    endif ~isfield(opt, 'cueStream'),    error('opt must have field ''cueStream''.');end% if ~iscell(opt.cueStream),%   opt.cueStream = {opt.cueStream};% end% % %Load the cue stimulus if a filename is given% if ischar(opt.cueStream),%     if ~isabsolutepath(opt.cueStream),%         opt.cueStream = strcat(BCI_DIR, 'acqusition/data/sound/', opt.cueStream);%     end%     [opt.cueStream, inputFs]= ...%         wavread([opt.cueStream '.wav']);%     if ~(opt.fs == inputFS),%         error('Sampling frequency of cue does not correspond with set sampling frequency');%     end% end% Create a structure with the different cues, ea locations, stored in it.% When opt.dualStim is set to true, this is done on the fly, due to varying% number of stimulus pairs.if ~opt.dualStim    cueList = struct;    for ii = 1:opt.speakerCount,        cueList(ii).wav = zeros(opt.speakerCount, length(opt.cueStream));        if ~opt.singleSpeaker,            if size(opt.cueStream, 1) == 1,                cueList(ii).wav(ii,:) = opt.cueStream;            else                if ismember(ii, opt.speakerSelected),                   cueList(ii).wav(ii,:) = opt.cueStream(find(opt.speakerSelected == ii),:);                end            end        else            if size(opt.cueStream, 1) == 1,                cueList(ii).wav(1,:) = opt.cueStream;            else                if ismember(ii, opt.speakerSelected),                   cueList(ii).wav(1,:) = opt.cueStream(find(opt.speakerSelected == ii),:);                end            end        end        % use calibrated speaker gain        cueList(ii).wav = opt.calibrated * cueList(ii).wav;    endend% Load the different speech files for experiment guidesspeech = struct;if isfield(opt, 'speech') && ~isempty(opt.speech),    soundNames = fieldnames(opt.speech);    for ii = 1:length(soundNames),        [sound, fs]= ...            wavread([opt.speech_dir '/speech_' getfield(opt.speech, char(soundNames(ii))) '.wav']);        if ~(fs == opt.fs),            error('Sampling frequency of speech does not correspond with set sampling frequency');        end        sound = 0.6*sound'; %0.3 should be better taken care of        % create a 8 channel sound out of a mono sound        container = [];        for iii = 1:opt.speakerCount,            container = cat(1, container, sound);        end        % use calibrated speaker gain        container = opt.calibrated * container;        speech = setfield(speech, char(soundNames(ii)), container);    endend% Load the different speech files for auditive countdownfor ii= 1:opt.countdown,    [sound, fs]= ...        wavread([opt.speech_dir '/speech_' int2str(ii) '.wav']);    if ~(fs == opt.fs),        error('Sampling frequency of counts does not correspond with set sampling frequency');    end    sound = 0.6*sound'; %0.3 should be better taken care of    % create a 8 channel sound out of a mono sound    container = [];    for iii = 1:opt.speakerCount,        container = cat(1, container, sound);    end    % use calibrated speaker gain    container = opt.calibrated * container;    count(ii).wav = container;end% if necessary, alter the amount of N to get a multiple of% lenght(opt.speakerSelected)if ~opt.dualStim && (mod(N, length(opt.speakerSelected)) > 0)    fprintf('Warning, number of presentations is not a multiple of the directions.\n');    fprintf('Now using a total number of %i presentations, instead of %i\n', N-mod(N, length(opt.speakerSelected)), N);    N = N-mod(N, length(opt.speakerSelected));elseif opt.dualStim && (mod(N, length(find_dual_cues(length(opt.speakerSelected), opt.dualDistance))) > 0)    maxLength = length(find_dual_cues(length(opt.speakerSelected), 1));    N = N-mod(N, maxLength);    fprintf('Warning, you are using %i locations with a distance of %i\n', length(opt.speakerSelected), opt.dualDistance);    fprintf('The maximal number of unique pairs is %i. N is set to %i\n', maxLength, N);    N = N-mod(N, maxLength);elseif opt.dualStim    maxLength = N;end% set containers for responsecorrectResponse = zeros(trials,N);buttonPressed = zeros(trials, N);reactionTime = zeros(trials,N);% create target sequencetarget_sequence = [];if trials < length(opt.speakerSelected);    target_sequence = randperm(length(opt.speakerSelected));    target_sequence = opt.speakerSelected(target_sequence(1:trials));else    for ii = 1:trials/length(opt.speakerSelected),        target_sequence = [target_sequence opt.speakerSelected(randperm(length(opt.speakerSelected)))];    end    if mod(trials, length(opt.speakerSelected)) > 0        for ii = 1:mod(trials, length(opt.speakerSelected)),            target_sequence = [target_sequence round(rand()*(length(opt.speakerSelected)-1))+1];        end    end%     target_sequence(:) = opt.speakerSelected(target_sequence(randperm(length(target_sequence))))endif ~isempty(opt.bv_host),    bvr_checkparport;endwaitForSync;if opt.test,    fprintf('Warning: test option set true: EEG is not recorded!\n');else    if ~isempty(opt.filename),        bvr_startrecording([opt.filename VP_CODE]);    else        warning('!*NOT* recording: opt.filename is empty');    endendppTrigger(251);%present intro speechif isfield(speech, 'intro'),    PsychPortAudio('FillBuffer', opt.pahandle, speech.intro);    PsychPortAudio('Start', opt.pahandle);    PsychPortAudio('Stop', opt.pahandle, 1);endpause(1);if isfield(speech, 'trialStart'),    PsychPortAudio('FillBuffer', opt.pahandle, speech.trialStart);    PsychPortAudio('Start', opt.pahandle);    PsychPortAudio('Stop', opt.pahandle, 1);endset(opt.handle_cross, 'Visible', 'on');drawnow; pause(2);if opt.req_response,     state= acquire_bv(1000, opt.bv_host);endfor zz = 1:trials,    %**************************************************************    % RUN <trials> amount of trials, with <N> amount of stimuli    %**************************************************************    % create the cue_sequence for presentation    % if dualStim is true, it creates the possible unique pairs: output 2xN    % if dualStim is false, it creates a sequence of 1xN, where each location is presented equally often.    set(opt.handle_cross, 'Visible', 'on');drawnow;    cue_sequence = [];    if ~opt.dualStim,%         for ii = 1:N/length(opt.speakerSelected),%             cue_sequence = [cue_sequence opt.speakerSelected(randperm(length(opt.speakerSelected)))];%         end        cue_sequence = createSequence(N);    else        for ii = 1:N/maxLength,            tempSequence = find_dual_cues(length(opt.speakerSelected), 1);            randOrder = randperm(length(tempSequence));            tempSequence(1,:) = opt.speakerSelected(tempSequence(1,randOrder));            tempSequence(2,:) = opt.speakerSelected(tempSequence(2,randOrder));                        cue_sequence = [cue_sequence find_dual_cues(length(opt.speakerSelected), 1)];        end    end    %     cue_sequence = removeDuplicatePairs(cue_sequence);    % play the target introduction audiostream    fprintf('Now giving target direction: %i (%i)\n', target_sequence(zz), zz);    if isfield(speech, 'targetDirection'),        PsychPortAudio('FillBuffer', opt.pahandle, speech.targetDirection);        PsychPortAudio('Start', opt.pahandle);        PsychPortAudio('Stop', opt.pahandle, 1);    end        pause(1);        if opt.visualPresent       oldColor = get(opt.handle_loc(target_sequence(zz)), 'FaceColor');       set(opt.handle_loc(target_sequence(zz)), 'FaceColor', [1 0 0]);       set(opt.handle_loc, 'Visible', 'on');       drawnow;    end        % play the cuesound from the target direction    if ~opt.dualStim        for repI = 1:opt.repeatTarget,            PsychPortAudio('FillBuffer', opt.pahandle, cueList(target_sequence(zz)).wav);            PsychPortAudio('Start', opt.pahandle);            PsychPortAudio('Stop', opt.pahandle, 1);            pause(.4);        end    else        newSound = zeros(opt.speakerCount, length(opt.cueStream));        newSound(target_sequence(zz),:) = opt.cueStream;        % use calibrated speaker gain        newSound = opt.calibrated * newSound;        PsychPortAudio('FillBuffer', opt.pahandle, newSound);        PsychPortAudio('Start', opt.pahandle);        PsychPortAudio('Stop', opt.pahandle, 1);    end    pause(3);    if opt.visualPresent       set(opt.handle_loc(target_sequence(zz)), 'FaceColor', oldColor);       set(opt.handle_loc, 'Visible', 'off');       drawnow;    end        pause(0.5);        % initiate countdown    for ii= opt.countdown:-1:1,        fprintf('Trial start in %i seconds\n', ii);        PsychPortAudio('FillBuffer', opt.pahandle, count(ii).wav);        PsychPortAudio('Start', opt.pahandle);        pause(1);        PsychPortAudio('Stop', opt.pahandle, 1);    end    ppTrigger(252);    pause(1);    waitForSync;    if opt.req_response,         [dmy] = acquire_bv(state); %clear the que    end        % start the actual experiment loop    for i= 1:N,        if ~opt.dualStim            PsychPortAudio('FillBuffer', opt.pahandle, cueList(cue_sequence(i)).wav);            if cue_sequence(i) == target_sequence(zz),              ppTrigger(cue_sequence(i)+10);            else              ppTrigger(cue_sequence(i));            end        else            newSound = zeros(opt.speakerCount, length(opt.cueStream));            newSound(cue_sequence(1,i),:) = opt.cueStream;            newSound(cue_sequence(2,i),:) = opt.cueStream;            newSound = opt.calibrated * newSound;            PsychPortAudio('FillBuffer', opt.pahandle, newSound);            % create trigger for dual stim            trigger = dec2bin(2^(opt.speakerCount-1));            trigger(1) = '0';            trigger(cue_sequence(1,i)) = '1';            trigger(cue_sequence(2,i)) = '1';            ppTrigger(bin2dec(trigger));        end        PsychPortAudio('Start', opt.pahandle);        if opt.req_response,            startTime = clock;            isdown = 0;            resp = [];                        while isempty(resp) && 1000*etime(clock,startTime)<opt.resp_latency,              [dmy,bn,mp,mt,md]= acquire_bv(state);              for mm= 1:length(mt),                resp= strmatch(mt{mm}, opt.response_markers);                if ~isempty(resp),                  continue;                end              end              pause(0.001);  %% this is to allow breaks            end            endTime = clock;                        if isempty(resp),              if cue_sequence(i) ~= target_sequence(zz),                correctResponse(zz, i) = 1;                buttonPressed(zz, i) = 0;                fprintf('Counted %i correct miss.\n', length(find(abs(buttonPressed(zz,1:i)-1) .* correctResponse(zz,1:i))));              else                if cue_sequence(i) == target_sequence(zz),                  correctResponse(zz, i) = 0;                  buttonPressed(zz, i) = 0;                  fprintf('Counted %i false negative.\n', length(find(abs(buttonPressed(zz,1:i)-1) .* abs(correctResponse(zz,1:i)-1))));                end              end            else              if cue_sequence(i) == target_sequence(zz),%                 ppTrigger('R1');                correctResponse(zz, i) = 1;                buttonPressed(zz, i) = 1;                reactionTime(zz, i) = etime(endTime, startTime)*1000;                fprintf('Counted %i correct hit.\n', length(find(buttonPressed(zz,1:i) .* correctResponse(zz,1:i))));                fprintf('Reactiontime was: %i msec\n', int32(reactionTime(zz,i)));              else%                 ppTrigger('R1');                correctResponse(zz, i) = 0;                buttonPressed(zz, i) = 1;                reactionTime(zz, i) = etime(endTime, startTime)*1000;                fprintf('Counted %i false positive.\n', length(find(buttonPressed(zz,1:i) .* abs(correctResponse(zz,1:i)-1))));                fprintf('Reactiontime was: %i msec\n', int32(reactionTime(zz,i)));              end            end        end        trial_duration = opt.isi + rand()*opt.isi_jitter;        waitForSync(trial_duration);        PsychPortAudio('Stop', opt.pahandle, 1);    end        if opt.req_response,        falseN = length(find(abs(buttonPressed(zz,:)-1) .* abs(correctResponse(zz,:)-1)));        falseP = length(find(buttonPressed(zz,:) .* abs(correctResponse(zz,:)-1)));        trueN = length(find(abs(buttonPressed(zz,:)-1) .* correctResponse(zz,:)));        trueP = length(find(buttonPressed(zz,:) .* correctResponse(zz,:)));        fprintf('True positives: %i\n', trueP);        fprintf('True negatives: %i\n', trueN);        fprintf('False positives: %i\n', falseP);        fprintf('False negatives: %i\n', falseN);    end        ppTrigger(253);    pause(2);    if zz ~= trials,        set(opt.handle_cross, 'Visible', 'off');        if isfield(speech, 'relax'),            PsychPortAudio('FillBuffer', opt.pahandle, speech.relax);            PsychPortAudio('Start', opt.pahandle);            PsychPortAudio('Stop', opt.pahandle, 1);        end        pause(opt.breakSize);        if isfield(speech, 'nextTrial'),            PsychPortAudio('FillBuffer', opt.pahandle, speech.nextTrial);            PsychPortAudio('Start', opt.pahandle);            PsychPortAudio('Stop', opt.pahandle, 1);        end        pause(1);    else        if isfield(speech, 'trialStop'),            PsychPortAudio('FillBuffer', opt.pahandle, speech.trialStop);            PsychPortAudio('Start', opt.pahandle);            PsychPortAudio('Stop', opt.pahandle, 1);        end        pause(0.1);    end    if opt.dualStim        outputCueSequence(zz,:,:) = cue_sequence;    else        outputCueSequence(zz,:) = cue_sequence;    endendcue_sequence = outputCueSequence;ppTrigger(254);pause(1);if ~opt.test & ~isempty(opt.filename),    bvr_sendcommand('stoprecording');endpause(3);% delete(h_msg);