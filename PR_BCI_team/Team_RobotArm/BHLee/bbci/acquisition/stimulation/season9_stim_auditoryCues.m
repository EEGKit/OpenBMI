function stim= stim_auditoryCues(stim, varargin)%STIM_VISUALCUES - Presentation of Visual Cues%%Synopsis:% stim_visualCues(STIM, <OPT>)%%Arguments:% STIM% OPT: struct or property/value list of optional arguments:% 'breaks': % 'msg_vpos': Scalar. Vertical position of message text object. Default: 0.57.% 'msg_spec': Cell array. Text object specifications for message text object.%   Default: {'FontSize',0.1, 'FontWeight','bold', 'Color',[.9 0 0]})% blanker@cs.tu-berlin.de, Jul-2007global VP_CODE VP_SCREEN SOUND_DIRif ~isstruct(stim),  error('first argument STIM must be a struct');endif ~isfield(stim, 'cue'),  error('first argument STIM must have a field ''cue''.');endopt= propertylist2struct(varargin{:});opt= set_defaults(opt, ...                  'filename', '', ...                  'test', 0, ...                  'position', VP_SCREEN, ...                  'bv_host', 'localhost', ...                  'background', 0.5*[1 1 1], ...                  'countdown', 7, ...                  'countdown_fontsize', 0.3, ...                  'duration_intro', 10000, ...                  'msg_vpos', 0.1, ...                  'msg_spec', {'FontSize',0.1, 'FontWeight','bold', ...                               'Color',0.3*[1 1 1]}, ...                  'speech_dir', [SOUND_DIR 'english\'], ...                  'breaks',inf, ...                  'break_minevents',7, ...                  'break_markers', [249 250], ...                  'break_msg', 'Short break for %d s', ...                  'break_countdown', 5, ...                  'break_pause_recording', 0, ...                  'msg_fin','fin');stim= set_defaults(stim, ...                   'msg_intro', 'be prepared');                                  if length(opt.breaks)==1,  opt.breaks= [opt.breaks 10];endif ~isempty(opt.bv_host),  bvr_checkparport;endif ~isfield(stim.cue, 'handle'),  opt.handle_background= stimutil_initFigure(opt);%  H= num2cell(stimutil_cueStrings({stim.cue.string}, opt));%  [stim.cue.handle]= deal(H{:});endsounds = struct('file',[],'fs',[]);for i = 1:length(stim.cue)        switch(stim.cue(i).classes)            case 'left'                [stim.cue(i).audi.wav,stim.cue(i).audi.fs] = wavread([opt.speech_dir 'speech_left']);            case 'right'                [stim.cue(i).audi.wav,stim.cue(i).audi.fs] = wavread([opt.speech_dir 'speech_right']);            case {'down','foot'},                [stim.cue(i).audi.wav,stim.cue(i).audi.fs] = wavread([opt.speech_dir 'speech_foot']);        endend [sounds(1).wav,sounds(1).fs] = wavread([opt.speech_dir 'speech_stop']);[sounds(2).wav,sounds(2).fs] = wavread([opt.speech_dir 'speech_eyes_closed']);[sounds(3).wav,sounds(3).fs] = wavread([opt.speech_dir 'speech_eyes_open']);[sounds(4).wav,sounds(4).fs] = wavread([opt.speech_dir 'speech_relax']);[sounds(5).wav,sounds(5).fs] = wavread([opt.speech_dir 'speech_over']);opt.sounds = sounds;for ii= 1:opt.countdown,  [sound_counting(ii).wav, sound_counting(ii).fs]= ...      wavread([opt.speech_dir '/speech_' int2str(ii) '.wav']);endopt.sound_counting = sound_counting;[opt.handle_msg, opt.handle_background]= stimutil_initMsg(opt);if ~isfield(stim, 'prelude'),  %% Fuer ungeduldige (wird später eh angezeigt)  set(opt.handle_msg, 'String',stim.msg_intro);endif ~opt.test,  if ~isempty(opt.filename),    bvr_startrecording([opt.filename VP_CODE]);  else    warning('!*NOT* recording: opt.filename is empty');  end  if isfield(stim, 'desc'),    stimutil_showDescription(stim.desc, opt);  endelse  opt.break_pause_recording= 0;endppTrigger(251);if ~isfield(opt, 'handle_cross') | isempty(opt.handle_cross),  opt.handle_cross= stimutil_fixationCross(opt);endif isfield(stim, 'prelude'),  show_cue_sequence(stim.prelude, opt, 'add_to_marker',10);  pause(1);endshow_cue_sequence(stim, opt);ppTrigger(254);set(opt.handle_msg, 'String',opt.msg_fin, 'Visible','on');pause(1);if ~opt.test & ~isempty(opt.filename),  bvr_sendcommand('stoprecording');endreturn;function show_cue_sequence(stim, varargin)stim= set_defaults(stim, ...                   'msg_intro', 'Be prepared');if ~isfield(stim.cue, 'marker'),  [stim.cue.marker]= deal(NaN);endopt= propertylist2struct(varargin{:});opt= set_defaults(opt, ...                  'add_to_marker', 0);nClasses= length(stim.cue);nEvents= sum([stim.cue(:).nEvents]);cue_sequence= [];for cc= 1:nClasses,  if isnan(stim.cue(cc).marker),    stim.cue(cc).marker= cc;  end  if size(stim.cue(cc).timing,1)==1,    stim.cue(cc).timing(2,:)= zeros(1, size(stim.cue(cc).timing,2));  end  cue_sequence= cat(1, cue_sequence, cc*ones(stim.cue(cc).nEvents,1));endcue_sequence= cue_sequence(randperm(nEvents));set(opt.handle_msg, 'String',stim.msg_intro, 'Visible','on');pause(opt.duration_intro/1000);set(opt.handle_msg, 'Visible','off');if ~opt.test,  pause(2);  wavplay(opt.sounds(4).wav,opt.sounds(2).fs,'async');  pause(opt.duration_intro/1000);  for ii= opt.countdown:-1:1,    wavplay(opt.sound_counting(ii).wav, opt.sound_counting(ii).fs, 'async');    set(opt.handle_msg, 'String',sprintf('Start in %d s', ii),'Visible','on');     drawnow;    pause(1);  end  set(opt.handle_msg, 'Visible','off');  ppTrigger(252);  pause(1);endwaitForSync;for ei= 1:nEvents,  cc= cue_sequence(ei);  tim= stim.cue(cc).timing(1,:) + rand(1,3).*stim.cue(cc).timing(2,:);    set(opt.handle_cross, 'Visible','on');  if tim(1)>0,    ppTrigger(101);    drawnow;    waitForSync(tim(1));  end    %% set(stim.cue(cc).handle, 'Visible','on');  wavplay(opt.sounds(2).wav,opt.sounds(2).fs,'async');  %wavplay(stim.cue(cc).audi.wav, stim.cue(cc).audi.fs,'async');  ppTrigger(1);  drawnow;  waitForSync(tim(2));  if tim(3)>0,    %set([opt.handle_cross; stim.cue(cc).handle], 'Visible','off');    wavplay(opt.sounds(1).wav, opt.sounds(1).fs, 'async');    ppTrigger(100);    ppTrigger(2)    drawnow;    waitForSync(tim(3));  else    wavplay(opt.sounds(1).wav, opt.sounds(1).fs, 'async');%    set(stim.cue(cc).handle, 'Visible','off');  end    if mod(ei, opt.breaks(1))==0 & ei<nEvents-opt.break_minevents,    set(opt.handle_cross, 'Visible','off');    wavplay(opt.sounds(4).wav, opt.sounds(4).fs, 'async');    if opt.break_pause_recording,      bvr_sendcommand('pauserecording');    end    pause(opt.breaks(2));    for ii= opt.countdown:-1:1,      wavplay(opt.sound_counting(ii).wav, opt.sound_counting(ii).fs, 'async');      set(opt.handle_msg, 'String',sprintf('Start in %d s', ii), ...                        'Visible','on');       drawnow;      pause(1);    end    if opt.break_pause_recording,      bvr_sendcommand('resumerecording');      pause(0.5);    end    %% TODO: WAVPLAY countdown  endendppTrigger(253);pause(1);set(opt.handle_cross, 'Visible','off');