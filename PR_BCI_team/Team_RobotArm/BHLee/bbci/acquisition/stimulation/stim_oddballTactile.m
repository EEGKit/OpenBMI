function cue_sequence= stim_oddballAuditory(N, varargin);%STIM_ODDBALLTACTILE - Stimulus Presentation for Tactile Oddball%%Synopsis:% SEQ= stim_oddballTactile(N, <OPT>)% SEQ= stim_oddballTactile(N, PERC_DEV, <OPT>)%%Arguments:% N: Number of stimuli% PERC_DEV: Percentage of deviants% OPT: Struct or property/value list of optional properties:% 'perc_dev': Scalar: percentage of deviants% 'isi':      Scalar: inter-stimulus interval [ms]% 'isi_jitter': default: 0.% 'intensity': Scalar, or [i1 i2], where i1 is the (average) intensity at %      the beginning of the experiment and i2 at the end (linear%      interpolation), default: [1 1].% 'intensity_jitter': default: 0.% 'require_response': Boolean: if true, a response stimulus is expected%    within the ISI.% 'response_markers': Cell array 1x2 of strings: description of response%    markers expected for STD and DEV stimuli. Default: {'R 16','R  8'}.% 'msg_vpos': Scalar. Vertical position of message text object. Default: 0.57.% 'msg_spec': Cell array. Text object specifications for message text object.%   Default: {'FontSize',0.1, 'FontWeight','bold', 'Color',[.9 0 0]})%%Triggers:%   1: STD stimulus%   2: DEV stimulus% 251: beginning of relaxing period% 252: beginning of main experiment ue(after countdown)% 253: end of main experiment% 254: endglobal BCI_DIR VP_CODEif length(varargin)>0 & isnumeric(varargin{1}),  opt= propertylist2struct('perc_dev',varargin{1}, varargin{2:end});else  opt= propertylist2struct(varargin{:});endopt= set_defaults(opt, ...                  'filename', 'oddball_tactile', ...                  'test', 0, ...                  'perc_dev', 0.15, ...                  'isi', 1500,...                  'isi_jitter', 0, ...                  'intensity', [1 1], ...                  'intensity_jitter_perc', 0, ...                  'require_response', 1, ...                  'response_markers', {'R 16', 'R  8'}, ...                  'bv_host', 'localhost', ...                  'fs', 22050, ...                  'breaks',inf, ...                  'break_minevents',7, ...                  'break_markers', [249 250], ...                  'break_msg', 'Short break for %d s', ...                  'break_countdown', 7, ...                  'countdown', 7, ...                  'test_trials', 5, ...                  'relax_duration', 3000, ...                  'msg_relax','entspannen', ...                  'msg_fin','fin');if length(opt.intensity)==1,  opt.intensity= opt.intensity([1 1]);endif length(opt.breaks)==1,  opt.breaks= [opt.breaks 10];endif ~isfield(opt, 'cue_dev') | ~isfield(opt, 'cue_std'),  error('opt must have fields ''cue_dev'' and ''cue_std''.');endif ~iscell(opt.cue_dev),  opt.cue_dev= {opt.cue_dev};endif ~iscell(opt.cue_std),  opt.cue_std= {opt.cue_std};endif ischar(opt.cue_dev{1}),  if ~isabsolutepath(opt.cue_dev{1}),    opt.cue_dev= strcat(BCI_DIR, 'acquisition/data/sound/cues_tactile/', opt.cue_dev);    opt.cue_std= strcat(BCI_DIR, 'acquisition/data/sound/cues_tactile/', opt.cue_std);  end  for ii= 1:length(opt.cue_dev),    [opt.cue_dev{ii}, opt.fs]= ...        wavread([opt.cue_dev{ii} '.wav']);  end  for ii= 1:length(opt.std_dev),    [opt.std_dev{ii}, opt.fs]= ...        wavread([opt.cue_std{ii} '.wav']);  endendcue_sequence= zeros(1,N);cue_sequence(1:round(N*opt.perc_dev))= 1;cue_sequence= cue_sequence(randperm(N));if ~isempty(opt.bv_host),  bvr_checkparport;endopt.handle_background= stimutil_initFigure(opt);if opt.test_trials>0  h_msg= stimutil_countdown(opt.countdown, opt, ...    'countdown_msg','test trials start in %d s');  set(h_msg, 'String', 'non-targets');  pause(1);  ifac= opt.intensity(1);  waitForSync;  for ii= 1:opt.test_trials,    ci= ceil(rand*length(opt.cue_std));    wavplay(ifac*opt.cue_std{ci}, opt.fs, 'async');    waitForSync(opt.isi);  end  pause(1);  set(h_msg, 'String', 'targets');  pause(1);  waitForSync;  for ii= 1:opt.test_trials,    ci= ceil(rand*length(opt.cue_dev));    wavplay(ifac*opt.cue_dev{ci}, opt.fs, 'async');    waitForSync(opt.isi);  end  pause(1);else  h_msg= stimutil_initMsg(opt);endset(h_msg, 'String',opt.msg_relax, 'Visible','on');drawnow;waitForSync;if opt.test,  fprintf('Warning: test option set true: EEG is not recorded!\n');  pause(1)  set(h_msg, 'string',' ');  drawnow;else  ppTrigger(251);  if ~isempty(opt.filename),    bvr_startrecording([opt.filename VP_CODE]);  else    warning('!*NOT* recording: opt.filename is empty');  end  waitForSync(opt.relax_duration);  set(h_msg, 'string',' ');  pause(1);  stimutil_countdown(opt.countdown, opt)  ppTrigger(252);  pause(1);endaverage_intensity= linspace(opt.intensity(1), opt.intensity(2), N);if opt.require_response,  response= zeros(N, 1);  correct= NaN*zeros(N, 1);  state= acquire_bv(1000, opt.bv_host);endwaitForSync;for i= 1:N,  ifac= average_intensity(i) + (rand-0.5)*opt.intensity_jitter_perc*average_intensity(i);  [1+cue_sequence(i) ifac]  ppTrigger(1+cue_sequence(i));  if cue_sequence(i),    ci= ceil(rand*length(opt.cue_dev));    wavplay(ifac*opt.cue_dev{ci}, opt.fs, 'async');  else    ci= ceil(rand*length(opt.cue_std));    wavplay(ifac*opt.cue_std{ci}, opt.fs, 'async');  end  trial_duration= opt.isi + rand*opt.isi_jitter;  if opt.require_response,    t0= clock;    resp= [];    [dmy]= acquire_bv(state);  %% clear the queue    while isempty(resp) & 1000*etime(clock,t0)<trial_duration-50,      [dmy,bn,mp,mt,md]= acquire_bv(state);      for mm= 1:length(mt),        resp= strmatch(mt{mm}, opt.response_markers);        if ~isempty(resp),          continue;        end      end      pause(0.001);  %% this is to allow breaks    end    response(i)= etime(clock,t0);    if ~isempty(resp),      correct(i)= (resp==2-cue_sequence(i));    end    fprintf('%d:%d  (%d missed)\n', sum(correct==1), sum(correct==0), ...      sum(isnan(correct(1:i))));  end  if mod(i, opt.breaks(1))==0 & i<N-opt.break_minevents,    pause(1);    stimutil_break(opt, 'break_duration',opt.breaks(2));  end  waitForSync(trial_duration);endppTrigger(253);pause(1);if opt.require_response,  iGood= find(correct==1);  iBad= find(correct==0);  msg= sprintf('%d hits  :  %d errors  (%d missed)', ...               length(iGood), length(iBad), sum(isnan(correct)));  set(h_msg, 'String',msg, 'FontSize',0.5*get(h_msg,'FontSize'));    fprintf('%s\n', msg);  fprintf('|  average response time:  ');  if ~isempty(iGood),    fprintf('%.2f s on hits  | ', mean(response(iGood)));  end  if ~isempty(iBad),    fprintf('%.2f s on errors  |', mean(response(iBad)));  end  fprintf('\n');else  set(h_msg, 'String',opt.msg_fin);endppTrigger(254);pause(1);if ~opt.test & ~isempty(opt.filename),  bvr_sendcommand('stoprecording');endpause(5);delete(h_msg);