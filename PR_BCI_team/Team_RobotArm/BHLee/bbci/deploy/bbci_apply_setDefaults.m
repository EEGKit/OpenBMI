function bbci= bbci_apply_setDefaults(bbci)
%BBCI_APPLY_SETDEFAULTS - Set default values in bbci structure for bbci_apply
%
%Synopsis:
%  BBCI= bbci_apply_setDefaults
%  BBCI= bbci_apply_setDefaults(BBCI)
%
%Arguments:
%  BBCI - Structure of bbci_apply which specifies processing and 
%      classification, type 'help bbci_apply_structures' for detailed
%      information about the fields of this structure.
%
%Output:
%  BBCI - Updated bbci structure

% 02-2011 Benjamin Blankertz


global TODAY_DIR TMP_DIR

if nargin==0,
  bbci= [];
end

bbci= set_defaults(bbci, ...
                   'source', struct, ...
                   'marker', struct, ...
                   'signal', struct, ...
                   'feature', struct, ...
                   'classifier', struct, ...
                   'control', struct, ...
                   'feedback', struct, ...
                   'log', struct, ...
                   'adaptation', struct, ...
                   'quit_condition', struct);

[bbci.source, isdefault_source]= ...
    set_defaults(bbci.source, ...
                 'acquire_fcn', @bbci_acquire_bv, ...
                 'acquire_param', {}, ...
                 'min_blocklength', 40, ...
                 'clab', '*', ...
                 'marker_mapping_fcn', [], ...
                 'log', struct);
if length(bbci.source)==1 && ...
      isequal(bbci.source.acquire_fcn, @bbci_acquire_bv) && ...
      isdefault_source.acquire_param,
  bbci.source.acquire_param= {'fs', 100, 'connected', 1};
end
bbci.source.log= set_defaults(bbci.source.log, ...
                              'output', 0, ...
                              'data_packets', 0, ...
                              'markers', 1, ...
                              'time_fmt', '%08.3fs');

bbci.marker= set_defaults(bbci.marker, ...
                          'queue_length', 100);

bbci.signal= set_defaults(bbci.signal, ...
                             'source', 1, ...
                             'clab', '*', ...
                             'buffer_size', 5*1000, ...
                             'proc', {}, ...
                             'chans', {});
bbci.signal= transformProc2FcnParam(bbci.signal);

bbci.feature= set_defaults(bbci.feature, ...
                           'signal', 1, ...
                           'fcn', '');
bbci.feature= transformProc2FcnParam(bbci.feature);

bbci.classifier= set_defaults(bbci.classifier, ...
                              'feature', 1, ...
                              'apply_fcn', @apply_separatingHyperplane);

bbci.control= set_defaults(bbci.control, ...
                           'classifier', 1, ...
                           'fcn', '', ...
                           'param', {}, ...
                           'condition', []);

for ic= 1:length(bbci.control),
  cfy_list= bbci.control(ic).classifier;
  feat_list= [bbci.classifier(cfy_list).feature];
  cp_list= [bbci.feature(feat_list).signal];
  bbci.control(ic).source_list= unique([bbci.signal(cp_list).source]);
  if ~isempty(bbci.control(ic).condition),
    ivals= cat(1, bbci.feature(feat_list).ival);
    overrun= max(ivals(:,2));
    bbci.control(ic).condition= set_defaults(bbci.control(ic).condition, ...
                                             'marker',{}, ...
                                             'overrun', overrun);
  end
end
bbci.control= transformProc2FcnParam(bbci.control);

bbci.feedback= set_defaults(bbci.feedback, ...
                            'control', 1, ...
                            'receiver', '');
if ismember(bbci.feedback.receiver, {'pyff','matlab'}),
  bbci.feedback= set_defaults(bbci.feedback, ...
                              'host', '127.0.0.1', ...
                              'port', 12345);
end

[bbci.adaptation, adapt_default]= ...
    set_defaults(bbci.adaptation, ...
                 'active', 1, ...
                 'mode', 'classifier', ...
                 'classifier', 1, ...
                 'fcn', '', ...
                 'param', {}, ...
                 'folder', TMP_DIR, ...
                 'file', 'bbci_adaptation',...
                 'save_everytime', 0, ...
                 'load_classifier', 0, ...
                 'log', struct('output','screen'));
% Assign filename according to the name of the adaptation function:
for k= 1:length(bbci.adaptation),
  if adapt_default.file && ~isempty(bbci.adaptation(k).fcn),
    bbci.adaptation(k).file= func2str(bbci.adaptation(k).fcn);
  end
  if adapt_default.active && isempty(bbci.adaptation(k).fcn),
    bbci.adaptation(k).active= 0;
  end
end
% For multiple adapatation: if all filenames are the same, append
% the index number to make them distinct.
if length(bbci.adaptation)>1,
  fnames= {bbci.adaptation.file};
  if all(cellfun(@(x) strcmp(x,fnames{1}), fnames)),
    for k= 1:length(bbci.adaptation),
      bbci.adaptation(k).file= [bbci.adaptation(k).file, sprintf('-%02d', k)];
    end
  end
end
bbci.adaptation= transformProc2FcnParam(bbci.adaptation);

if all(cellfun(@isempty, {bbci.feedback.receiver})),
  default_output= 'screen';
else
  default_output= 0;
end
header_line= '# Log file of BBCI online - <TIME>';
bbci.log= set_defaults(bbci.log, ...
                       'output', default_output, ...
                       'folder', TODAY_DIR, ...
                       'file', 'bbci_apply_log', ...
                       'header', {header_line}, ...
                       'force_overwriting', 0, ...
                       'time_fmt', '%08.3fs', ...
                       'clock', 0, ...
                       'classifier', 0, ...
                       'markers', 0);
if ~strcmp(bbci.log.header{1}, header_line),
  dim= min(find(size(bbci.log.header)>1));
  if isempty(dim), 
    dim= 1;
  end
  bbci.log.header= cat(dim, {header_line}, bbci.log.header);
end

bbci.quit_condition= set_defaults(bbci.quit_condition, ...
                                  'running_time', inf, ...
                                  'marker', '');
end